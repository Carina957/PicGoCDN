## Javascript面试题

#### 1、判断类型的方法

相关参考1[https://www.jianshu.com/p/21dfb470809c]

相关参考2[https://www.cnblogs.com/onepixel/p/5126046.html]

[参考1](https://www.jianshu.com/p/21dfb470809c, '参考1')
**[参考2](https://www.cnblogs.com/onepixel/p/5126046.html， '参考2')**

<https://www.cnblogs.com/onepixel/p/5126046.html>

[参考资料1][https://www.cnblogs.com/onepixel/p/5126046.html]

```

function varType(v){
 if ( typeof v=== "object" ){
  if (v=== null ) return 'null' ;
  if (v. constructor )
   return (v. constructor .toString()).match(/(?: )[/w/$]+/)[ 0 ];
  if ( typeof typeof2=== 'undefined' && window .execScript){
   window .execScript( 'Function vbsTypeName(o):vbsTypeName=TypeName(o):End Function' , 'vbscript' );
   window .execScript( 'function typeof2(o){return vbsTypeName(o)}' , 'jscript' );
  }
  if ( typeof typeof2!== 'undefined' ){
   return typeof2(v);
  }
  return "object" ;
 }
 return typeof v;
}
//对于普通js常量和js对象，各浏览器是基本一致的
alert (varType()); //undefined
alert (varType( 100 )); //number
alert (varType({})); //Object
alert (varType([])); //Array
alert (varType(/ /)); //RegExp
alert (varType( new Date ())); //Date
alert (varType( Date )); //function
alert (varType( Object )); //function
alert (varType( RegExp )); //function
//对于DOM对象，各浏览器可能会有不同值
alert (varType( window )); //IE:HTMLWindow2 FF:Window
alert (varType( document )); //IE:HTMLDocument FF:HTMLDocument
alert (varType( document .body)); //IE:HTMLBody FF:HTMLBodyElement
alert (varType( Option )); //IE:Object FF:function
alert (varType( Image )); //IE:Object FF:function
alert (varType( navigator )); //IE:DispHTMLNavigator FF:Navigator
//以下几个只适用于IE，其他内核浏览器不支持
alert (varType( ActiveXObject )); //IE:function
alert (varType( Enumerator )); //IE:function
alert (varType( new ActiveXObject ( "Scripting.Dictionary" ))); //IE:Dictionary
alert (varType( new Enumerator ())); //IE:Enumerator

递归一个对象
var obj = { a:{w:1,y:2,x:3},
    b:{s:4,j:5,x:6},
    c:{car:7,cat:8,mao:9}
}
function f(s){
    for(var i in s){
    if(typeof s[i]=="object"){
    f(s[i])
    }else{
       console.log(s[i]);
      }
    }
}
f(obj);
```

#### 1、手动实现一种时间复杂度为 O(n log n) 的排序算法，可用任意语言实现，也可以只写出伪代码。

参考网址：https://www.cnblogs.com/onepixel/p/7674659.html[https://www.cnblogs.com/onepixel/p/7674659.html

#### 2、用任意一种语言实现一个函数，判断一个给定整数数组中是否存在某两个元素之和恰好等于一个给定值 k，存在则返回 true，否则返回 false。该函数的输入参数有两个，第一个参数为整数数组 nums，第二个参数为整数 k，返回值为布尔值。可以参考以下签名，写出实现。【要求时间复杂度为 O(n)，n 为数组长度】

```js
// JavaScript
var checkTwoSum = function(nums, k) {
// Write your code here
var nums = [1,2,43,34,78,33];
    function f(nums,k) {
         //让数组从小到大排序
     	nums.sort(function (a,b) {
     		return a - b;
     	})
         //nums = [1,2 33,34,43,78]
     	var i = 0,j = nums.length-1;  //5
     	while (i<j){
     		if (nums[i] + nums[j] === k){
     			return true;
    		}else  if(nums[i]+nums[j]<k){
     			i++;
     		}else{
     			j--;
     		}
     	}
     	return false;
    }
     console.log(f(nums,36));
};

```

#### 3、用两种以上方式实现一个方法或对象，调用时会打印中文的“你好xx”(要求已定义的代码不能修改，自定义的代码不能出现“你好”);

```js
const obj = {
		say(){
			Array.from(arguments).forEach(item=>{
				console.log(`${this.str} ${item}`)
			})
		}
	}
	Object.defineProperties(obj,{
		'str':{
			value:'hello',
			writable:false
		}
	})
	const objZh = {};
	Object.defineProperties(objZh,{
		'str':{
			value:'你好',
			writable:false
		}
	})

//第一种方法
    function f(){
    	obj.say.call(objZh,...arguments);
     }
	f('foo','bar')

//第二种方法
    var o = {}
    o.str = objZh.str;
    o.say = obj.say;
    o.say();

```

#### 4、下面的输出结果

```js
Var fullname = “Michael Jordan”;
Var obj = {
fullname:”Kobe Bryant”,
    prop:{
       fullname:”Allen Iverson”,
       getFullname:function(){
          return this.fullname
    	}
    } 
}
Console.log(obj.prop.getFullname());  //输出Allen Iverson，this指向的时prop
Var test = obj.prop.getFullname;
Console.log(test());                //输出Michael Jordan，此时的this已经指向window
```

#### 5、对this对象的理解，JS作⽤域及作⽤域链

```
作用域: 就是变量和函数的可访问范围。

ES5中有全局作用域和局部作用域（函数作用域）。
ES6中新增了块级作用域，一个大括号就是一个作用域。
	全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域
	局部作用域：在固定的代码片段才能被访问
	
作用域链: 变量的查找顺序，先在当前作用域查找，如果没有，会沿着当前作用域一级一级查找。

一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。
但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链


	通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。
	1.当执行函数时，总是先从函数内部找寻局部变量。
	2.如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上。

this代表的是当前对象，由于执行环境不同，所代表的对象也不同。
比如：
	1、在DOM0事件中this指向调用这个函数的对象。
	2、在构造函数中this指向创建新的实例
	3、在箭头函数中this指向当前函数外离他最近的对象
	4、当函数为全局函数时this指向 window  （在全局范围内，这代表全局对象，例如web浏览器中的 window 对象）
```

#### 6、模拟实现 call, apply, bind 

```js
	var foo = {
     	value: 1
     };
    function bar() {
     	console.log(this.value);
     }
     bar.call(foo); //call 改变了 this 的指向，指向到 foo， bar 函数执行了
     var foo = {
     	value: 1,
    	bar: function() {
     		console.log(this.value)
     	}
     };
    foo.bar(); // 1
    所以我们模拟的步骤可以分为：将函数设为对象的属性、执行该函数、删除该函数
    第一步 foo.fn = bar
    第二步 foo.fn()
    第三步delete foo.fn
```

####  7、将数组扁平化并去除其中重复数据，最终得到⼀个升序且不重复的数组  

```js
var old_arr=[ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];   
// 数组偏平化（Infinit 无限大）
// 数组偏平化（999 无限大）
var level_arr=old_arr.flat(4);
var level_arr=old_arr.flat(Infinit);
//数组去重
var Distinct=Array.from(new Set(level_arr));
// 排序
var sort=  Distinct.sort((a, b) =>a - b)
console.log("new arr",sort)
```

#### 8、 JavaScript基本编码规范  

```
<https://standardjs.com/rules-zhcn.html>
<https://www.cnblogs.com/burningmyself/p/9510442.html>	
1、避免在同一行声明多个变量
2、使用全等（===）代替恒等（==）
3、switch必须使用default分支
4、函数必须有返回值
5、for循环和if语句必须使用大括号
6、for in循环中的变量应该使用var关键字限定作用域，避免作用域污染。
7、构造函数命名时首字母大写。
8、合理的加注释、方便后期维护，提高代码的可读性。
9、使用字面量声明方式代替构造函数方式声明。

==========================================================================

1、变量  声明变量必须加上var关键字，而且每个var只声明一个变量，增加可读写。
2、常量 常量的命名方式：用大写字符，并用下划线分隔。
3、with(){}  尽量少用。
4、缩进  用4个空格作为一缩进，而不是使用tab
5、字符串过长截取   每行代码不超过80个字符。如代码过长，可使用+运算符拼接。
8、构造函数  对于构造函数，命名采用首字母大写，其他函数一律小写。
9、注释  合理的加上注释，有利于后期维护，提高可读性。
10、{}和[]   使用{}代替new Object()，使用[]代替new Array()
11、单引号（'） 尽量使用单引号（'），只在JSON文件中使用双引号。
12、变量和函数声明  变量名和函数名在JavaScript机制下会发生声明提升（也就是会提前到顶部声明），所以建议变量和函数应该在使用前声明。
13、使用===和!==代替==和!=  在JavaScript中，比较运算符进行计算时会进行强制转换，==和!=会产生一些意想不到的结果，所以应该用“严格相等”===
14、换行  在语句块和下一个语句之间留一个空行，提高可读性。
15、命名  构造函数或类名使用驼峰式命名
16、语句  对于复合语句，if, for, while, do, switch, try … catch 等代码体，函数定义的函数体，对象的定义等都需要放在花括号'{}'里面。
17、for-in  对于数组，尽量避免使用for-in


JS的几条基本规范
1、不要在同一行声明多个变量
2、请使用===/！==来比较true/false或者数值
3、使用对象字面量替代new Array这种形式
4、不要使用全局变量
5、Switch语句必须带有default分支
6、函数不应该有时候有返回值，有时候没有返回值
7、For循环必须使用大括号
8、IF语句必须使用大括号
9、for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染
```

#### 9、请写出输出值  

``` js
 (function () {
    var a = b = 5;
})()
console.log(b);    
console.log(a);  
输出：b为5、a 会报错。（a is not defined）
因为：b没有使用var声明则为全局变量，a属于局部变量，所以在函数外访问不到
```

#### 10、请写出输出值

``` js
var fullname = '张三';
var obj = {
    fullname: '李四',
    prop: {
        fullname: '王五',
        getFullname: function() {
            return this.fullname;
        }

    }

};
console.log(obj.prop.getFullname());   
var test = obj.prop.getFullname;
console.log(test());					   
console.log(test.call(obj.prop));

//结果为：王五、张三、王五
//第一个结果是正常的this指向、第二个test为全局，this则指向全局、第三个call改变了this指向
```

####  11、请问点击<buttion id="test"></button>会有反应么？为什么？

```js
$('#test').click(
    function (argument) {
        console.log(1);
    });
setTimeout(function () {
    console.log(2);
}, 0);
while (true) {
    console.log(3);
}
//答：没有反应，因为while是一个同步代码先执行又是一个死循环，如果没有while循环，会有反应的
```

#### 12、请写出输出结果  

```js
var Container = function(x) {
    this.__value = x;
}
Container.of = x => new Container(x);
Container.prototype.map = function(f) {
    return Container.of(f(this.__value))
}
var obj = Container.of(3)
    .map(x => x + 1)
    .map(x => 1 + x)
    .map(x => 'Result is ' + x);
console.log(obj.__value);  
//答：输出结果是5
```

#### 13、基本的数据结构有哪些？数组排序方法有哪些？请您简单的用javascript实现一下冒泡排序。  

```js
数据结构：数组、栈、队列、链表、树、集合、字典、哈希表/散列表、图
基本数据结构有：object、array，ES6新增的结构有set、map、
一、快速排序
	原理：取出数组的中间项，然后把数组剩下的每一项与该项进行比较，如果小于该项就放在该项的左边，大于该项就		放在该项的右边；再分别把左边的项和右边的项的中间项取出，重复上面的步骤到项数小于等于1为止；最后把所获得	的项进行拼接。
二、插入排序
	原理：取出数组的第一项放到新数组里，让剩余的每一项与新数组的每一项进行比较，小的放左边，大的放右边。
三、冒泡排序
	原理：相邻的两项进行比较，如果前面的一项大于（小于）后面的项，则交换位置。直到最大（最小）数沉底为止。
     var ary=[21,32,2,9,4];
        function bubbleSort(ary){
            for(var i=0; i<ary.length; i++){//正在进行第几次循环
                for(var j=0; j<ary.length-1-i; j++){//本次循环需要执行几次
                    if(ary[j]>ary[j+1]){
                        var tmp=ary[j];
                        ary[j]=ary[j+1];
                        ary[j+1]=tmp;
                    }
                }
            }
            return ary;
        }
       document.write(bubbleSort(ary));
```

#### 14、请写出深度拷贝这个arr数组的方法

```js
都引用数据类型来说，基本数据类型没有深拷贝和浅拷贝一说
	
什么是深拷贝
	concat()  slice()  扩展运算符 循环遍历的方式
什么是浅拷贝
	直接赋值
    var arr = [12,34];
	var arr1 = arr;


var a = { 'a': 1 }
var b = { 'b': 1 }
var c = { 'c': 1 }
var arr = [a, b, c];

1、	使用jquery的extend
2、	使用JSON.parse( )、JSON.stringify( )
3、  自己写函数实现

```

####   15、请写出如下输出值，并写出把注释去掉后的输出的值：

```js
this.a = 20;
var test = {
    a: 40,
    init: () => {
        console.log(this.a);
        function go() {
            // this.a = 60;
            console.log(this.a);
        }
        go.prototype.a = 50;
        return go;
    }
};
//var p = test.init();
//p();
new (test.init())();


```

#### 16、数组去重说出来几种方法

```js
1、首先声明一个新数组，并遍历原数组使用indexOf方法进行判断新数组中是否有原素中的元素，如果没有，就往新数组里添加，如果有则不添加
2、使用new  Set 进行去重，然后再转为数组
	// var arr1 = Array.from(new Set(arr))
3、filter  +  indexOf	
    //var arr1 = arr.filter(( item,index) = {
    return  arr.indexOf(item) === index
    })
```

#### 17、对es6了解有多少，使用过ES6 中的哪些新特性

```
	1.	模块化开发
	2.	箭头函数
	3.	函数参数默认值
	4.	模板字符串
	5.	解构赋值
	6.	对象属性简写
	7.	Promise
	8.	let与const
	9.	class 类
	10.	扩展运算符
	11、新增了数组、字符串、对象的方法
	12、for...of 
```

#### 18、箭头函数和普通函数的区别

```
区别：
	1、语法不同。
	2、箭头函数是匿名函数，不能作为构造函数，不能使用new。
	3、箭头函数不能绑定arguments，取而代之用rest参数...解决。
	4、箭头函数没有原型属性。
	5、箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值。
	6、箭头函数不能当做Generator函数,不能使用yield关键字.
```

#### 19、对promise的理解  

```
Promise是异步编程的一种解决方案，主要解决由于异步请求的多层嵌套造成的回调地狱问题。
Promise有三个状态和两个过程
	三个状态：pending（初始状态）、fulfilled（成功状态）、rejected（失败状态）；
	
	两个过程：pending==>fulfilled的过程和pending==>rejected的过程。
	缺点：promise的状态一旦改变则不会再变，是不可逆的
	
	方法：Promise是一个构造函数，自身有all、reject、resolve这几个方法，原型上有then和catch方法
```

#### 20、for in  和  for  of的区别

```
for。。。in的特点：
    1.index索引为字符串型数字，不能直接进行几何运算。
    2.遍历顺序有可能不是按照实际数组的内部顺序。
    3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组。
    对象的遍历（for...in..  keys() values() entries()）
for…of的特点：
    for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为对象没有迭代器.与forEach()不同的是，它可以正确响应break、continue和return语句
    for-of循环不支持普通对象，如果要迭代一个对象的属性，可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法
```

#### 21、遇到跨域问题是怎么解决的

```
http请求：是指从客户端到服务器端的请求消息
http请求的方式：
	HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。
	HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。
get请求与post请求的区别
http请求的状态码
网络请求的方式：
同源策略：
同源：
跨域：
跨域问题的解决方案：

前端解决跨域的方法：
			 webpack proxy  （这种方式打包就没有了）
			 jsonp
			 nginx 反向代理 
			 webpack plugin
后端设置：cors
推荐的方式：后端解决，后端不解决就得前端解决了。
原来没有前后端分离（所以没有跨域问题）
现在是前后端分离（有了跨域问题）
	小程序，H5，andriod都调一个后端
导致跨域的原因：前后端分离

同源策略：是浏览器的一种安全机制（同源策略是一种约定，它是浏览器最核心也是最基本的安全功能）
什么是不同源：
	由于现在做的项目都是前后端分离的模式，页面跟数据不在一起，需要从页面去后台请求数据，就是不同源。
线上跨域：
	1)jsonp 
	2) 后台在请求头里添加  Allow-access-origin:'*'
线下跨域：vue项目中在webpack-dev-server中配置使用 proxyTable反向代理(正向代理，反向代理)
	同源策略：是浏览器的安全策略。
	同源：协议名、域名、端口号必须完全一致。
什么情况会跨域：
	违背了同源策略就会产生跨域
解决跨域方法
	jsonp:前后端都需要改代码，jsonp不支持post请求，只支持get请求。
	cors 
	服务器代理
```

#### 22、单例模式  

```
JS设计模式：

设计模式：设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性.

单例模式  要求一个类有且只有一个实例
参考网址：
	https://segmentfault.com/a/1190000012430741
	https://blog.csdn.net/Liu_Jun_Tao/article/details/81236713

单例模式 (Singleton) 的实现在于保证一个特定类只有一个实例，第二次使用同一个类创建新对象的时候，应该得到与第一次创建对象完全相同的对象。
```

#### 23、对算法有什么了解，排序算法了解吗

```js
算法：就是一种解题思路
比如：（冒泡、选择、插入、快速）有自己写过吗？
	冒泡排序、数组去重、求最大值最小值、求完数、求水仙花数
原理：相临的两个数进行比较，第一个数比第二个数大或者小，则交换位置，直到最大的数或者最小的数沉低。
 var ary=[21,32,2,9,4];
    function bubbleSort(ary){
        for(var i=0; i<ary.length; i++){//正在进行第几次循环
            for(var j=0; j<ary.length-1-i; j++){//本次循环需要执行几次
                if(ary[j]>ary[j+1]){
                    var tmp=ary[j];
                    ary[j]=ary[j+1];
                    ary[j+1]=tmp;
                }
            }
        }
        return ary;
    }
    document.write(bubbleSort(ary));
参考网址：https://www.cnblogs.com/xiaomou/p/10118800.html
```

#### 24、使用过typescript、react、taro吗  

```
Typescript：
	1、TypeScript 是由微软开发的一款开源的编程语言 。
	2、TypeScript 是 Javascript 的超级， 遵循最新的 ES6、 Es5 规范。 TypeScript 从语言层面上扩展		了JavaScript的语法。
 	3、TypeScript 更像后端 java这样的面向对象语言可以让 js 开发大型企业项目 。
React：
	1、React是一个简单的javascript UI库
	2、遵循组件设计模式、声明式编程和函数式编程概念。
	3、它使用虚拟DOM来有效地操作DOM。
	4、单向数据流。 
Taro：
	1、Taro是一套遵循 React 语法规范的多端统一开发框架
	2、多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 		等的应用。
```

#### 25、图片轮播怎么做的

```
结构：
	<div class=”box”>
		<div>放置图片</div>
	</div>
外侧需要一个容器，容器内部再放置一个容器用来放置图片，给外侧容器设置overflow：hidden。
Js实现简单轮播思路：
	1、首先找到存放图片的容器
	2、开启一个定时器，每个多长时间就改变一次它的left值
	3、判断left值达到一定限度时，重新设置left值，达到轮播效果
```

#### 26、本地储存都有什么及区别  

```
本地存储有localStorage、sessionStorage和cookie，但他们之间是有区别的。
总结：
	它们都是用来保存信息的。
大小区别：
	localStorage、sessionStorage 可以存储5m，  cookie只能存储4kb。
有效期的区别：
	localStorage可以长期存储数据，浏览器关闭后数据不丢失，除非手动删除。
	sessionStorage存储数据在浏览器关闭时自动删除。
	Cookie可设置过期时间，过期之后浏览器关闭后自动消失。
安全问题：
	cookie会把消息上传到服务器端最不安全。
	Localstorage和sessionstorage都会留在本地所以更安全。
```

#### 27、XML和json的区别

```
(1).数据体积方面。
	JSON相对于XML来讲，数据的体积小，传递的速度更快些。
(2).数据交互方面。
	JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
(3).数据描述方面。
	JSON对数据的描述性比XML较差。
(4).传输速度方面。
	JSON的速度要远远快于XML。
```

#### 28、是否了解原生js  

```
了解、经常使用
```

#### 29、前端算法吗？冒泡排序、数组递归这些都会

```js
冒泡排序：
		var ary=[21,32,2,9,4];
    	function bubbleSort(ary){
        	for(var i=0; i<ary.length; i++){//正在进行第几次循环
            	for(var j=0; j<ary.length-1-i; j++){//本次循环需要执行几次
                	if(ary[j]>ary[j+1]){
                    	var tmp=ary[j];
                    	ary[j]=ary[j+1];
                    	ary[j+1]=tmp;
                	}
            	}
        	}
        	return ary;
   		}
    document.write(bubbleSort(ary));
递归：
	递归就是一个函数，只不过是自己调用了自己。
    比如使用setTimeout实现每秒输出123，那么就需要在setTimeout内再调用一次。
```

#### 30、var let const 区别

```
1、var声明的变量会挂载到window上，而let和const声明的变量不会。
2、var声明变量存在变量声明提升，let和const不存在变量声明提升。
3、let和const声明的变量有块作用域。
4、同一作用域下let和const不能声明同名变量，而var可以。
5、let和const声明的变量存在 暂时性死区。

const：
	一旦声明必须赋值,不能使用null占位。而且声明后不能再修改，如果声明的是复合类型数据，可以修改其属性。
	
	六种声明变量的方法：
		var let  const   function  import  class
```

#### 31、Es6 class  

```
ES6的class可以看作只是一个ES5生成实例对象的构造函数的语法糖。让对象原型写法更加清晰，对象实例化更像是一种面向对象编程，class类可以通过extend实现继承。
它和ES5的不同点：
	1、类内部定义的方法都是不可枚举的。
	2、ES6的class类必须使用new命令操作，而ES5的构造函数不用new也可以运行。
	3、ES6类不存在变量提升，不惜定义class之后才能实例化，不想ES5中可以将构造函数卸载实例化之后。
	4、ES5的继承，是指是先创造子类的实例对象this，然后将父类的方法添加到this上面。而ES6的机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。
```

#### 32、数组方法 、字符串方法

```
ES5中的数组方法有：
	Pop：删除数组中最后一个元素，返回删除的元素，原数组改变
	Push：向数组末尾处添加元素，返回数组长度，原数组改变
	Shift：删除数组中第一个元素，返回删除的元素，原数组改变
	Unshift：向数组中的一位置添加元素，返回数组的长度，原数组改变
	Reverse：数组反转，返回反转后的数组，原数组改变
	Concat：数组连接，返回一个新数组，原数组不变
	Join：数组转字符串，返回一个字符串，原数组不变
	indexOf：查找指定元素在数组中第一次出现的位置，找到返回对应的下标没找到返回-1，原数组不变
	lastIndexOf：查找指定元素在数组中最后一次出现的位置，找到返回对应的下标没找到返回-1，原数组不变
	sort：对数组进行排序，返回排序后的数组，原数组改变
	slice：截取数组元素，返回一个由截取的元素生成的心数组，原数组不变
	splice：删除、替换数组中的元素，返回修改后的数组，原数组改变
	
ES6新增方法：
	Filter：过滤指定数组中所有符合条件的元素，返回一个心数组，原数组不变
	Map：按照原数组的元素顺序依次处理元素，返回一个处理后的新数组，(数组元素是值类型则原数组不变，数组元素		为引用（对象）类型，则原数组改变)
	Some：用于检测数组中的元素是否满足指定条件，如果有一个符合条件的就返回true，如果没有符合条件的返回		false，原数组不变。
	Every：用于检测数组中的元素是否满足指定条件，如果都满足条件返回true，有一个不满足就返回false，原数组		不变
	Find：用于查找数组中符合条件的元素，返回原数组中满足条件的第一个值，不满足返回 undefined，原数组不		变。
	findIndex：用于查找数组中符合条件的元素，返回数组中满足条件的第一个值的下标，不满足返回-1，原数组不			变。
	Includes：用来判断一个数组是否包含一个指定的值，如果存在返回true，如果不存在返回false，原数组不变。
	
	
字符串的方法：
	ES5中的字符串方法有：
		
		
		
	ES6新增字符串方法：
        startsWith：参数字符串是否在原字符串的头部，是返回true、不是返回flase。
        endsWidth：参数字符串是否在源字符串的尾部，是返回true、不是返回flase。
        repeat：将原字符串重复n次，返回新字符串。
        padStart：用于头部补全，接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全字符串的元素。
        padEnd：用于尾部补全。接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全字符串的元素。
```

#### 33、ForEach和map、every、some、filter区别

```
1、通过map遍历返回的数据返回的新数组与原数组之间没有引用关系。
2、map遍历返回数组长度和原数组长度是完全相等的。
3、forEach不会不返回新数组，return,break失效。
```

#### 34、Post和get区别  

```
https://www.cnblogs.com/kangleweb/p/10930544.html

HTTP请求的方法：
	HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
	HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法
	
HTTP工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

get:一般用于信息获取，使用url传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符
post：一般用于修改服务器上的资源，对所发送的信息没有限制（post通过请求体将数据传向后台）
	在以下情况中，使用post请求
	1.无法使用缓存文件（更新服务器上的文件或数据库）
	2.向服务器发送大量数据（post没有数据限制）
	3.发送包含未知字符的用户输入时，post比get更稳定也更可靠
```

```
get和post的区别
1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些 2、get相对post安全性低
3、get有缓存，post没有
4、get体积小，post可以无限大
5、get的url参数可见，post不可见
6、get只接受ASCII字符的参数数据类型，post没有限制
7、get请求参数会保留历史记录，post中参数不会保留
8、get会被浏览器主动catch，post不会，需要手动设置
9、get在浏览器回退时无害，post会再次提交请求

什么时候使用post？

post一般用于修改服务器上的资源，对所发送的信息没有限制。比如

1、无法使用缓存文件（更新服务器上的文件或数据库）
2、向服务器发送大量数据（POST 没有数据量限制）
3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
```



#### 35、了解Eventloop（事件循环）吗？

```
js是单线程语言，一次只能完成一个任务，如果同时完成多个任务怎么办？js把任务分为同步和异步任务，把所有的同步放到主线程上去执行，把所有的异步任务放到事件队列里去，当所有的同步任务都执行完之后，去事件队列中看看有没有没有执行的异步任务，如果有把需要先执行的异步任务拉到主线程上去执行，当这个任务执行完后，再去事件队列里看有没有没完成的任务，如果有再把任务拉到主线程去执行。这样形成一个事件循环。

1、所有的同步任务都在主线程上执行，形成一个执行栈；
2、在主线程之外还存在一个任务队列，只要异步任务有了运行结果，就会在任务队列中放置一个事件
3、一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件、哪些异步任务，于是结束等待状态，进入执行栈，开始运行。
4、主线程会不断循环上面的第三步就是所谓的事件循环。
Js的单线程也叫主线程，js代码都是在主线程上执行的，我们要区分同步执行还是异步执行，异步执行的代码会对应这一个回调函数，不同任务对应不同的回调，不同的回调交给不同的模块去管理回调什么时候执行，这些模块什么时候把回调放入到事件对列中，JS会通过轮询的方式去询问这个事件队列是否有可执行的回调，如果有会将这个函数钩出去，钩到主线程上去执行。（所回调函数又叫钩子函数）

js他是单线程的，但是它分为同步任务和异步任务，同步任务会放到主线程中去执行，

在ES6中由于增加了promise，所以在异步任务中又分为宏任务和微任务
宏任务：setTimeout、setInterval、requestAnimationFrame
	1、宏任务所处的任务队列就是宏任务队列
	2、第一个宏任务队列中只有一个任务：执行主线程的js代码
	3、宏任务队列可以有多个
	4、当宏任务队列中的任务全部执行完会查看是否有位任务队列，如果有先执行微任务中的所有任务，如果没有就查看是否有宏任务
微任务：promise.then(回调)   process.nexttick(  )
	1、微任务所处的队列就是微任务队列
	2、只有一个微任务队列
	3、在上一个宏任务队列执行完毕后执行，如果有为任务队列就会执行微任务中的所有任务。
		首先在宏任务的队列中选取出第一个任务，执行完毕后取出为任务队列中的所有任务顺序执行，之后再取出宏任务，周而复始，直至两个队列的任务都取完。
		
		
		setTimeout(function(){
            console.log(1);
        },0);
        new Promise(function(a,b){
            console.log(2);
            for(var i=0;i<10;i++){
                i==9&&a();
            }
            console.log(3)
        }).then(function(){
            console.log(4)
        });
        console.log(5);
        
	正确输出顺序为：2，3，5，4，1；
```

####   36、this的几种典型应用  

```
this代表的是当前对象，由于执行环境不同，所代表的对象也不同。
比如：
	1、在DOM0事件中this指向调用这个函数的对象。
	2、使用new 构造函数（）方式  this指向创建的实例。
	3、This.在箭头函数中指向当前函数外离他最近的对象。
	4、当函数为全局函数时this指向 window。
```

#### 37、会不会做IOS端的适配 

```
IOS端的适配
	1、分析机型:整体上把现有的iOS屏幕分为两大类，非全面屏和全面屏
		非全面屏：（6、6s、7、8）和Plus系列（6 Plus、6s Plus、7 Plus、8 Plus)
		全面屏： iPhoneX  iPhoneXR  iPhone 11 等 
		屏幕尺寸总结，iPhone在逻辑像素共有四种，375x667，375x812，414x736，414x896
	2、安全区域
		非全面屏都是矩形，整个屏幕都是安全区域。
		全面屏受到大圆角、刘海以及底部的影响，UI图更需要考虑安全区域
		顶部44pt、 底部34pt	
	3、以iphone6为进行制作去适配其它机型，对iphoneX单独处理
		
	iphoneX的处理方案：
		通栏页面解决方案：
			1、对于通栏页面在页面顶部增加一层高度44px的黑色适配层，整个页面往下挪44px
			2、在页面底部增加一层高度34px的适配层，将操作栏上移34px
		非通栏页面解决方案：
			在页面底部增加一层高度34px的颜色块，将操作栏上移34px
			添加 viewport-fit	
		 	<meta name="viewport" content="width=device-width, initial-scale=1.0, 					viewport-fit=cover">
		 
	第一种解决方案：针对以上三点所需要对iphoneX添加适配层
		修改页面viewport-fit属性
		在H5页面链接一个iphonex.css来给iPhoneX访问的页面增加对应的适配层（专门对iphoneX的CS样式）
		在H5页面上给对应的dom结构加上适配的类名
			
	第二种解决方案：
    	针对iPhone X机型，在原生界面初始化的时候可选择是否要增加适配层。
        对于顶部通栏的页面，通过加URL参数来增加顶部黑色适配层。
		对于有底部操作栏（包括通栏和非通栏），通过加URL参数来增加底部适配层以及设置颜色。
	参考网址：
        https://www.cnblogs.com/zhangruiqi/p/7831019.html
```

####  38、了解过前端设计模式吗

```
了解过
设计模式有：工厂模式、单例模式、观察者模式、策略模式、代理模式。。。等

工厂模式：做一个对象创建的封装，并将创建的对象return出去
单例模式：只允许存在一个实例模式
观察者模式：经典案例事件监听一个元素同时监听多个同类型事件，元素对象即为发布者，每一个时间处理函数即为订阅者
策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换，从而避免很多if语句
代理模式：为其他对象提供一种代理以控制对这个对象的访问，为了不暴露执行对象的部分代码
```

#### 39、写出以下结果  

```js
var name = 'World!';
(function () {//第一步：自执行函数自动执行进入判断
	    if (typeof name === 'undefined') {
  	      var name = 'Jack';  //第二 将变量声明提升，赋值还在此处，所以判断条件成立
    	    console.log('Goodbye ' + name);//第三步进行输出，不会进入else语句中
    	} else {
    	    console.log('Hello ' + name);
   	 }})();
   	 
   	 
 答：输出结果为Goodbye  Jack， 
```

#### 40、实现一个算法，寻找字符串中出现次数最少的、并且首次出现位置最前的字符。如"cbaacfdeaebb"，符合要求的是"f"，因为他只出现了一次（次数最少）。并且比其他只出现一次的字符（如"d"）首次出现的位置最靠前。

```js
Var str = 'ksafa;sldfkasddfklwewkelfeerueuruieo2dofjklksafa;sldfkasddfkl'
	 function findMinStr(str){
	 	if(str.length === 0){
	 		return;
	 	}
	 	var obj = {};
	 	var minStr = str[0];
 	for(var i = 0 ;i  < str.length ; i ++){
	 		if(!obj[str[i]]){
	 			obj[str[i]] = 1;
	 		}else{
	 			obj[str[i]] ++;
	 		}
	 		// 当前最小值与当前值比较
	 		if(obj[minStr]>obj[str[i]]){
	 			minStr = str[i]
	 		}
	 	}
	 	// console.log(obj)
	 	// console.log(minStr)
	 	return minStr;
	}
	findMinStr(str)
```

####   41、谈谈你对js闭包的理解，并编写一个简单的闭包。  

```js
闭包就是能够读取函数内部变量的函数
	优点：能够读取函数内部的变量，让这些变量一直存在于内存中，不会在调用结束后，被垃圾回收机制回收。
	缺点：由于闭包会使函数中的变量保存在内存中，内存消耗很大，而且容易造成内存泄漏，（解决办法就是在退出函数之前，将不使用的局部变量删除）
	
	例子：
    function fn1(){
                var n = 999;
            nAdd = function(){
            n++;
    };
    function fn2(){
        console.log(n);
    }
    return fn2;
    }
    var result = fn1();
    result();	//999
    result();//1000
    
因为n被保存了起来并没有被垃圾回收机制回收，所以每次调用都会进行累加

垃圾回收机制
	不定期，不定时回收内存不再使用的变量，释放内存
垃圾回收机制有两种
	标记清除法
    	当一个变量进入到一个执行环境，就做一个标记，当不再使用这个变量时再做标记，回收那些标记为不再使用的变量
    引用计数法
    	当一个变量进入到一个执行环境，给这个变量进行计数为1，当不再使用这个变量的时候减1，回收那些计数为0的变量。
```

#### 42、请用原生js写一个简单的拖拽

```
如果要设置物体拖拽，那么必须使用三个事件，并且这三个事件的使用顺序不能颠倒。
需要onmousedown：鼠标按下事件、onmousemove：鼠标移动事件、onmouseup：鼠标抬起事件
拖拽的基本原理就是根据鼠标的移动来移动被拖拽的元素。鼠标的移动也就是x、y坐标的变化;元素的移动就是style.position的 top和left的改变。当然，并不是任何时候移动鼠标都要造成元素的移动，而应该判断鼠标左键的状态是否为按下状态，是否是在可拖拽的元素上按下的。
例子：

H5还增加拖拽API
	draggable="true"
	ondragstart
	ondragover
	ondrop 
	...
```

#### 43、var arr=[1,2,3,4,5,6,7,8,9]，用for循环累加  

```js
var n = 0;
for(var i = 0; i < arr.length;i++){
	n += arr[i]
}
console.log(n)
```

#### 44、promise是什么？async和await有什么区别  

```
promise是一个异步编程的解决方案，减少了代码量，提高了代码可读性，有效解决了回调地狱问题，它可以链式调用。

async的用法，它作为一个关键字放到函数前面， 调用该函数会返回一个promise 对象如果只是async,promise 差不多，但有了await就不一样了，await 关键字只能放到async 函数里面，await是等待的意思。其实它后面可以放任何表达式，不过我们更多的是放一个返回promise 对象的表达式，它等待的是promise 对象的执行完毕，并返回结果。
```

#### 45、深拷贝和浅拷贝你是怎么理解的  

```js
深拷贝和浅拷贝是对引用数据类型来说的。
对于如何区分深拷贝与浅拷贝，简单来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，如果B没变，那就是深拷贝。
数组的深拷贝可以使用：
	1、slice、concat实现对数组的深拷贝（注：当数组里面的值是基本数据类型属于深拷贝，比如string、number、boolean，当数组里面值为引用类型时属于浅拷贝，比如object、array）
	2、使用扩展运算符实现深拷贝
对象的深拷贝：
	1、使用JSON对象的JSON.stringify和JSON.parse实现深拷贝。
	（例：var obj1 = {a:1,b:2} var obj2 = JSON.parse（JSON.stringify(obj1)）
	2、使用object.assign实现深拷贝。
	（例：var obj1 = {a:1,b:2} var obj2 = object.assign（{}，obj1）//将obj1赋值给一个空对象然后		再赋值给obj2
3、通过jQuery的extend方法实现深拷贝
	var newArray = $.extend(true,[ ],array); // true为深拷贝，false为浅拷贝

浅拷贝：
	- concat
	- slice
	- 三点运算符
	- Object.assign
深拷贝
	- JSON.parse(JSON.stringify(source)) ---> 不能处理函数数据
	- 自己封装实现深度克隆
        function checkoutType(target) {
              return Object.prototype.toString.call(target).slice(8, -1)
            }
            function clone(target) {
              let result, targetType = checkoutType(target);
              // 检测克隆目标的数据类型
              if(targetType === 'Array'){
                result = [];
              }else if(targetType === 'Object'){
                result = {};
              }else {
                return target;
              }
              // 思考： 选用哪种方式遍历？？？  需求； 对象的key，数组的index ，结论： for in
              for(let i in target){
                // 获取个体元素
                // result[i] = target[i] 如果原数据中有引用数据类型，就是浅拷贝
                if(checkoutType(target[i]) === 'Array' || 'Object'){
                  result[i] = clone(target[i])
                }else {
                  result[i] = target[i]
                }
              }
              return result;
            }
        - 使用jq中的$.extend()方法
      
     var arr = [{a:1},{b:2}]; 进行深拷贝
```

#### 46、for 、for in 、for each 有什么区别  

```
for：  
	语法复杂
for。。。in的特点：
	index索引为字符串型数字，不能直接进行几何运算
	遍历顺序有可能不是按照实际数组的内部顺序
	使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象。
foeEach：
	不会遍历原型链上的属性
	不能像响应break、return
```

```
forEach、for in、for of三者区别
forEach更多的用来遍历数组

for in 一般常用来遍历对象或json

for of数组对象都可以遍历，遍历对象需要通过和Object.keys()

for in循环出的是key，for of循环出的是value
```

#### 47、怎么用JS获取一个盒子的宽高  

```js
var box = document.getElementById("box")
//获取元素设置的高度，为带单位的字符串类型
var contentHeight = window.getComputedStyle(box,null).height 
//获取元素设置的高度，为不带单位的数值类型
box.clientHeight 
//获取盒子自身实际高度，为不带单位的数值类型
box.offsetHeight
```

#### 48、localStorage、sessionStorage和cookie是什么

```
它们都是用来保存信息的
大小区别：
    localStorage、sessionStorage 可以存储5m，  cookie只能存储4kb。
有效期的区别：
	localStorage可以长期存储数据，浏览器关闭后数据不丢失，除非手动删除。
	sessionStorage存储数据在浏览器关闭时自动删除。
	cookie可设置过期时间，浏览器关闭后自动消失。
安全问题：
	cookie会把消息上传到服务器端最不安全。
	localstorage和sessionstorage都会留在本地所以更安全。
存储位置不同：
	localstorage和sessionstorage是把数据存储到本地，cookie是把数据存储在服务端。
```

#### 49、http常见的状态码有什么？301和303有什么区别

```
什么是http请求：就是指从客户端到服务器端的请求消息。
http包含三部分：
	1、请求头
	2、响应头
	3、状态码
	
http状态码分为五类：
	1开头的代表信息状态码
	2开头的代表成功状态码
	3开头的代表重定向状态码
	4开头的代表客户端错误状态码
	5开头代表服务端错误状态码
常用状态码有：
	200：请求成功
	301：被请求的资源已经永久移动到新位置
	304：所请求的资源未修改（缓存）。
	404：服务器无法根据客户端的请求找到资源
	500：服务器内部错误，无法完成请求
	503：由于超载或系统维护，服务器暂时无法处理客户端请求
301与303的区别：
	301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。
	
	303状态码：对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。
```

```
301
永久性重定向，该状态码表示请求的资源已被分配了新的URL，以后应使用资源现在所指的URL

302
临时重定向。表示请求的资源已被分配了新的URL，希望用户本次使用新的URL访问。和301相似，但302表示的资源不是永久移动，只是临时性的。

303
由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。
303明确表示客户端应当采用get方法获取资源。

307
临时重定向。该状态码与302有相同的含义。尽管302标准禁止post变化get，但实际使用时大家不遵守。 307会遵照浏览器标准，不会从post变为get。但是对于处理响应时的行为，各种浏览器有可能出现不同的情况。
```

#### 50、 ==和===的区别  

```
== 	会自动转换类型再去比较值是否相等
===	不会自动转类型，并且进行比较时值与数据类型都要相等
```

#### 51、forEach的使用方法  

```js
var arr= ['acb', 'vvv', 'index', 'html'];
bbb.forEach(function(item, index, arr) {
     console.log(item); 	//item为数组中的每一个元素
     console.log(index);	//下标
     console.log(arr);		//数组本身
}
```

#### 52、什么是栈  

```
栈：
	是一种只能从表的一端存取数据且遵循“先进后出”原则的线性存储结构，一端被称为栈顶，相对的把另一端成为底。
	向一个栈插入元素叫进栈，它是把新元素放到栈顶元素的上边使之成为新的栈顶元素。
	删除元素叫出栈（退栈），它是把栈顶元素删除，使其相邻的元素成为新的栈顶元素。
```

#### 53、求1-1000之间的完数

```js
什么完数：
	所有约数之和不包括他本身，等于他本身
    6 = 1 + 2 + 3
	28 = 1 + 2 + 4 + 7 + 14
for(var i = I; i <= 1000; i++){
		var sum = 0;
		for(var j = 1;j <= i/2;j++){	//因为完数的因数最大只能是该数的一半所以 i <= j/2
			if(i % j === 0){			//判断j是否是i的因数
				sum = sum + j;		//条件成立则将进行累加
			}
		}
    if(sum === i){		
        Console.log( i )	
    }
}
```

#### 54、js的三大组成部分  

```
Js由ECMAscript、DOM、BOM三部分组成
ECMAscript:主要是用来描述javascript的语法部分
BOM:浏览器对象模型(结合javascript和BOM提供的API对浏览器进行操作)
DOM:文档对象模型(结合javascript和DOM提供的API对HTML文档或XML文档进行操作)
```

#### 55、undefinde和null的区别  

```
如果使用==进行比较的话那么他们两个是等价的
undefined：
	1、声明了变量没有赋值时变量为undefined
	2、调用函数时应该提供实参，而没提供时，形参则为undefined
	3、对象没有赋值的属性，该属性为undefined
	4、函数没有返回值时，默认返回undefined
null：
	1、作为函数的参数，表示该函数的参数不是对象。
	2、作为对象原型链的终点。
		
因此我的理解是这样的：
	undefined是访问一个初始化变量时返回的值，而null是访问一个不存在的对象时所返回的值。因此可以把		undefined看作是一个空变量，null看作是一个空对象。
```

#### 56、js的基本数据类型

```
Js的基本数据类型有：string、number、boolean、null、undefined，ES6中symbol
复杂数据类型有：object
```

#### 57、遇到过哪些兼容性问题  

```js
是要处理IE浏览器和非IE浏览器之间的兼容

1、获取滚动距离的兼容处理
	document.documentElement.scrollTop ()   非IE
    document.body.scrollTop()   ==> 兼容IE  
2、阻止冒泡的兼容处理
	e.stopPropagation()非IE   ||    e.cancelBubble 兼容IE
3、阻止默认行为
	preventDefault( ) 非IE  ||  return  false  兼容IE
4、DOM2添加监听事件的兼容处理
	addEventListener 非IE || attachEvent  兼容IE
5、删除DOM2事件监听
	removeEventListener 非IE  || detachEvent  兼容IE
    。。。
```

#### 58、什么情况下引发跨域，前端解决跨域的方法有哪些？

```
引发跨域的几种情况：
	1、不同域名引起的跨域：（www.a.com和www.b.com）
	2、主域名和子域名不同引起的跨域（www.a.com和sss.a.com）
	3、不同协议引起的跨域（http://www.a.com和https://www.a.com）
	4、IP和域名引起的跨域（123.23.23.12和www.a.com）
	
	一句好描述：就是不同源的情况需要跨域。
	
前端解决跨域的方法：
	1、通过jsonp跨域  jsonp只能处理get请求
	2、Nginx代理跨域
	3、Location.hash + iframe跨域
	4、Window.name + iframe跨域
	
	开发中常用的解决跨域请求的方式是代理：
	
```

####   59、对同源策略理解  

```
同源策略是一种约定，它是浏览器最核心也是最基本的安全功能。
	所谓的同源就是同协议、同域名、同端口则为同源，即便有两个不同的域名指向同一个IP地址，耶非同源。
```

#### 60、跨域返回状态码是多少

```
CROS跨域
```

#### 61、请求状态码有哪些，了解http吗？常见的状态码有哪些、以及其含义是什么。有时候说一下范围比如 1**表示什么  2**表示什么 。。。。  

```
http状态码分为五类：
	1开头的代表信息状态码
	2开头的代表成功状态码
	3开头的代表重定向状态码
	4开头的代表客户端错误状态码
	5开头代表服务端错误状态码
	
http状态码有很多，常用状态码有：
	200：请求成功
	301：被请求的资源已经永久移动到新位置
	304：所请求的资源未修改。
	404：服务器无法根据客户端的请求找到资源
	500：服务器内部错误，无法完成请求
	503：由于超载或系统维护，服务器暂时无法处理客户端请求
```

#### 62、数组去重的方法有哪些、列举一些常见的或你自己所掌握的

```js
1、首先声明一个新数组，并遍历原数组使用indexOf方法进行判断新数组中是否有原素中的元素，如果没有，就往新数组里添加，如果有则不添加
2、使用new  Set 进行去重，然后再转为数组
	var arr1 = Array.from(new Set(arr))
3、filter  +  indexOf	
    var arr1 = arr.filter(( item,index) = {
    	return  arr.indexOf(item) === index
    })
```

#### 63、如果没有promise，怎么封装一个promise

```js
class Mypromise{
		constructor(executor){
			this.state = 'pending';
			//成功存放的数组
			this.onResolvedCallbacks = [];
			//失败存放的数组
			this.onRejectedCallbacks = [];
			let resolve = value=>{
				if(this.state === 'pending'){
					this.state = 'fulfilled';
					//一旦resolve执行，调用成功数组的函数
					this.onResolvedCallbacks.forEach(fn=>fn(value));
				}
			}
			let reject = reason =>{
				if(this.state === 'pending'){
					this.state = 'rejected';
					//一旦reject执行，调用失败数组的函数
					this.onRejectedCallbacks.forEach(fn=>fn(reason));
				}
			}

			try{
				executor(resolve,reject)

			}catch(error){
				reject(error);
			}

		}
		then(onFulfilled,onRejected){
			//当状态state为pending时
			if(this.state === 'pending'){
				//onFulfilled传入到成功数组
				this.onResolvedCallbacks.push(onFulfilled);
				//onRejected传入失败数组
				this.onRejectedCallbacks.push(onRejected)
			}
		}

	}

	let p = new Mypromise((resolve,reject)=>{
		setTimeout(function(){
			resolve('data1')
		},1000)
	})

	p.then(res=>{
		console.log('success:' + res)
	},(err)=>{
		console.log('err:' + err)
	})


	p.then(res=>{
		console.log('success:' + res)
	},(err)=>{
		console.log('err:' + err)
	})
```

#### 64、Js单线程跟单例模式了解过嘛  

```
Js本身就是一个单线程语言，单线程是指一次只能做一件事情.
浏览器在执行任务时是多线程的，也可以使用异步任务将异步任务放到事件队列里去，
当同步任务执行完时，会到任务队列中询问是否有要执行的任务，如果有则拿到主线程去执行直到任务队列中的所有异步任务执行完。

单例模式(是一种设计模式) (Singleton) 的实现在于保证一个特定类只有一个实例，第二次使用同一个类创建新对象的时候，应该得到与第一次创建对象完全相同的对象。
```

#### 65、变量声明提升  

```
var有变量声明提升,将变量的声明提升到当前的作用域最开始的位置,但赋值还是在原来位置
函数也存在声明提升.
```

#### 66、函数call apply 

```
相同点：都是改变this的指向，改变后的this指向传入的第一个参数。
不同点：传值方式不同
	Call方法：传递参数是一个一个传入的。（call（obj，arg1，arg2，arg3））
	Apply方法：传递参数是以数组形式传入的。（apply（obj，[ ] || arr））
```

```
call apply bind的区别
```

#### 67、如果没有promis的时候你是怎么进行数据请求优化的  

```
第一种方法，也是最常用的一种方法，做一个bool类型的字段去判断，如果第一次点击按钮bool字段设置为true，线程中进行数据查询，响应数据后再将字段改为false。如果第一次按钮请求还未结束，再去点击按钮，判断一下，如果字段值为true，就不去执行请求操作。

第二种方法，在点击按钮的时候记录当前时间，然后去监听它，如果两次点击按钮间隔500毫米内，就不去请求数据，反之则请求。

第三种方法，如果是多层嵌套进行数据请求的话，也是设置一个变量bool值为false，等数据请求回来之后，将其值改为true,当其值为true的时候 再进行第二次数据请求。
```

#### 68、解释一下原型链  

```
原型链就是通过原型继承在原型之间建立起来的链型结构被称为原型链
对象属性查找顺序为：
    先在对象的私有属性中查找，如果找到则返回该属性对应的值，如果没有找到，就会沿着__proto__属性到它的原型中查找，找到则返会对应的值，没找到，那么会沿着原型链向上查找，直到找到Object构造方法的原型为止，如果还没找到则返回undefined。
```

#### 69、js是怎么解决异步的问题 

```
使用ES6的promise对象，主要用来解决多层嵌套的异步请求造成的回调地狱问题。
async await
```

####  70、js单线程机制怎么去改变他的运行顺序  

```
把同步任务改成异步任务（可以使用定时器setTimeout 延迟一次）
```

#### 71、节流和防抖的区别  

```
https://www.cnblogs.com/youma/p/10559331.html

两者都是优化高频率执行js代码的一种手段。
函数防抖（debounce）：
	一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。（主要应用场景有：input验证、搜索联想、resize）
	
函数节流（throttle）：
	一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。（主要应用场景有：scroll、touchmove）
```

#### 72、编程题  

```js
/**
* @param {*} value 带检测的变量
* @param {String} type 目标类型，包括undefined,null,Number,String,Array
* @return {Boolean} 变量是否属于目标类型
*/
function typeChecker(value, type) {
// 在此填入内容
    if(typeof value === 'object'){
			if(type === 'null'){
				return true
			}else if(value instanceof eval(type)){
				return true;
			}

		}else if(typeof value === 'undefined'){
			return true
		}else{
			return true
		}	
}

typeChecker([1,2], 'Array'); // true
typeChcker(null, 'null'); // true
```

#### 73、编程题实现Child类，使Child类继承自Parent  

```js
function Parent(id) {
this.id = id;
}
Parent.prototype.output = function() {
return 'id:' + id;
}

function Child(id) {
// 在此填入内容
   Parent.call(this,id);
    this.output = function(){
    	return 'id:' + this.id
    }
}
let a = new Child(1);
a.id; // 1
a.output(); // id:1
```

#### 74、谈谈对闭包的理解  

```js
闭包就是能够读取函数内部变量的函数
优点：
	能够读取函数内部的变量，让这些变量一直存在于内存中，不会在调用结束后，被垃圾回收机制回收。
缺点：
	闭包会使函数中的变量保存在内存中，内存消耗很大，而且容易造成内存泄漏，（解决办法就是在退出函数之前，将不使用的局部变量删除）

造成内存泄露的几种情况：
	1）意外的全局变量引起的内存泄露
    function leak(){  
      leak="xxx";//leak成为一个全局变量，不会被回收  
    }
	2）闭包引起的内存泄露
	3）没有清理的DOM元素引用
	4）被遗忘的定时器或者回调 
	5）子元素存在引起的内存泄露
	
什么是垃圾回收机制：垃圾收集器会定期找出那些不在继续使用的变量，然后释放其内存。
垃圾回收机制两个方法：
	1、标记清除：
		进入执行环境（函数中声明变量）的时候，将变量标记"进入环境"，当变量离开环境时，标记为："离开环境"。某一个时刻，垃圾回收器会进行过滤，将标记为“离开环境”的变量回收。
        大部分浏览器以此方式进行垃圾回收.
	2、引用计数：
		当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。
```

#### 75、js怎么检测类型  

``` 
最常见的判断方法使用typeof.
number string boolean object  function  undefined 

判断已知对象类型的方法instanceof（比如arr instanceof Array， d instanceof Date）

使用对象的constructor判断

使用jQuery的type（）方法判断
```

#### 76、Promise 对象有哪几种状态以及方法

```
promise是异步编程的解决方案，减少了代码量，提高了代码可读性、可以有效解决回调地狱问题（e恶魔金字塔），可以链式调用。

有三个状态分别是：pending（初始状态）、fulfilled（成功状态）、rejected（失败状态）
Promise有两种状态的改变方式：pending==>resolved、pending==>rejected，状态一旦改变不会再变
Promise是一个构造函数，自身有all、reject、resolve这几个方法，原型上有then和catch、方法


All方法，让所有异步对象执行完毕才调用。
```

#### 77、Import和require区别 

```
import是客户端引入模块的一种语法
require是服务器端引入模块一种语法

Import是ES6的一个语法标准，它是编译时的、require是commonjs的语法，是执行时的
	Require它相当于module.exports的传送门，module.exports后面的内容是什么，require的结果就是什么，再把require的结果赋值给某个变量，相当于把require和module.exports进行平行空间的位置重叠。
	Import是编译时的，它必须放在文件开头，而且使用格式也是确定的，他不会将整个模块运行后赋值给某个对象，而是只选择import的接口进行编译，这样在性能上比require好很多，require是赋值过程，import是解构过程。
	
区别：
	Commonjs（require）
	1、对基本类型，属于复制
	2、对于复杂数据类型，属于浅拷贝
	3、在使用require加载模块时，就会运行整个模块的代码（同步加载）
	4、使用require加载已经加载过的模块时，不会再一次执行，而是从缓存中读取，除非清除缓存
ES6模块（import）
	1、import属于动态只读引用（impot a from “a”，不管是基本数据类型还是复杂数据类型）
	2、import虽然写在文件顶部，但是脚本执行碰到这个只读变量时，才执行被加载的模块（异步加载）
	3、对于动态来说，原始值发生变化，import加载的值也会发生变化。（不管是基本数据类型还是复杂数据类型）
```

####  78、 Es6新增 

```
模块化、箭头函数、函数参数默认值、模板字符串、解构赋值、对象属性简写、Promise、let与const、for….of、展开运算符
```

####  79、一个字符串hello有几种方法给每个字符后面加个空格

```js
先转为数组，然后再给每个元素加一个空格，最后再转换为字符串
	var str = “hello”
	var arr = str.split(“”)
	for(var i = 0;i < arr.length; i++){ 
        arr[i] += ” ”;
    }	
	console.log(arr.join(“”))
```

#### 80、前端缓存有哪些 具体怎么实现 

```
前端缓存分为两部分：http缓存、浏览器缓存
http缓存：
	强缓存，主要是采用响应头中的cache-control和expires两个字段进行控制。
	
浏览器缓存的话有：cookie、localstorage、sessionstorage
	Cookie：主要用于用户信息的存储，容量为4kb
	Localstorage、sessionstorage的存储量为5mb
```

####  81、安全性问题（xss）

```
Xss：是指恶意攻击者往web页面中插入恶意script代码，当用户浏览该网页时，嵌入其中的恶意script代码就会执行，从而达到恶意攻击用户的目的。
Xss的攻击方式：
	反射型：（发送请求时，XSS代码出现在URL中，作为输入提交到服务器）
	存储型：（存储型的XSS代码会存储在服务器端、数据库、内存、文件系统等）
DOM XSS：（不需要直接参与，通过浏览器端的DOM解析，进行攻击）
	危害：通过cookie盗取cookie、使用js或css破坏页面的正常结构与样式、流量劫持。
	解决方法：对cookie进行保护（对重要的cookie设置httponly）对用户输入数据进行编码、解码、过滤。
```

####   82、Es6数组forEach   map    filter     some  every 都表示什么  

```
首先forEach、map、filter、some都是遍历数组的方法，都是用来遍历数组。
forEach：
	不能响应return、break
map：
	按照原数组的元素顺序依次处理元素，返回一个处理后的新数组，数组元素是值类型则原数组不变，数组元素为引用类型，则原数组改变
filter：
	过滤指定数组中所有符合条件的元素，返回一个新数组，原数组不变
some：
	用于检测数组中的元素是否满足指定条件，如果有一个符合条件的就返回true，如果没有符合条件的就返回false，原数组不变
	
every:
```

#### 83、理解 async/await以及对Generator的优势

```
async await 是用来解决异步的，async函数是Generator函数的语法糖
使用关键字async来表示，在函数内部使用 await 来表示异步
async函数返回一个 Promise 对象，可以使用then方法添加回调函数
当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句
async较Generator的优势：
1、内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样
2、更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　
3、更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值
4、返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用
```

#### 84、使用箭头函数应注意什么？

```
1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）
2、不能够使用arguments对象
3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数
```

#### 85、介绍下 Set、Map的区别？

```
应用场景：Set用于数据重组，Map用于数据储存
区别：
    Set：　
        1、成员不能重复
        2、只有键值没有键名，类似数组
        3、可以遍历，方法有add, delete,has
    Map:
        1、本质上是健值对的集合，类似集合
        2、可以遍历，可以跟各种数据格式转换
```

#### 86、jsonp的原理

```js
1）创建script标签
		var script = document.createElement('script');
2)设置回调函数
	function getData(data){
		//数据请求回来会被触发的函数
		console.log(data);
	}
3)设置script标签的src属性，设置请求的地址
		script.src = 'http://localhost:3000?callback=getData'
4)让script生效
		document.body.appendChild(script)
5）后台设置代码
  ...
```

#### 87、forEach、map、some、every遍历数组的区别

```
区别：
	1、forEach没有返回值，不支持break、continue。
	2、map按照原数组的元素顺序依次处理元素，返回一个处理后的新数组，(数组元素是值类型则原数组不变，数组元素为引用（对象）类型，则原数组改变)
	3、some用于检测数组中的元素是否满足指定条件，如果有一个符合条件的就返回true，如果没有符合条件的返回		false，原数组不变。
	4、every用于检测数组中的元素是否满足指定条件，所有元素都符合条件才返回true，如果没有符合条件的返回		false，原数组不变。
```

#### 88、 前端性能优化的方法？ 

```
（1）、当需要设置的样式很多时设置className而不是直接操作style。
（2）、避免在页面的主题布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
（3）、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
（4）、减少http请求次数：CSS Sprites，JS、CSS源码压缩，图片大小控制合适；网页GZIP压缩，CDN托管，data缓存，图片服务器。
（5）、图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳。
（6）、前端模板 JS+数据，减少由于html标签导致的贷款浪费，前端用变量保存AJAX请求结果，每次操作本地数据，减少请求次数。
（7）、少用全局变量，缓存DOM节点查找的结果。减少IO（输入/输出）读取操作。
（8）、避免使用CSS Expression(css 表达式)又称动态属性（Dynamic properties）。
（9）、减少DOM操作；部署前，图片压缩、代码压缩；优化js代码结构，减少冗余代码；减少http请求，合理设置http缓存；使用内容分发cdn加速；静态资源缓存；图片延迟加载；
```

#### 89、 JS跨域请求的方式，能写几种写几种?  

```
（1）、通过jsonp跨域；
（2）、通过修改document.domain来跨子域；
（3）、使用window.name来进行跨域；
（4）、使用HTML5新引进的window.postMessage方法来进行跨域（ie6 7不支持）；
（5）、CORS需要服务器设置header:Access-Control-Allow-Origin；
（6）、nginx反向代理 这个方法可以不用目标服务器配合，不过需要搭建一个中转nginx服务器，用于转发请求。
```

#### 90、document.write和innerHTML的区别

```
document.write是直接写入到页面的内容流，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。

innerHTML则是DOM页面元素的一个属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改document.documentElement.innerElement。

innerHTML将内容写入某个DOM节点，不会导致页面全部重绘

innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。
```

#### 91xml和json的区别

```
(1).数据体积方面。
	JSON相对于XML来讲，数据的体积小，传递的速度更快些。
(2).数据交互方面。
	JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
(3).数据描述方面。
	JSON对数据的描述性比XML较差。
(4).传输速度方面。
	JSON的速度要远远快于XML。
```

#### 92、什么叫优雅降级和渐进增强？

```
渐进增强 progressive enhancement：
针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 graceful degradation：
一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

区别：
	a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给
	b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要
	c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带
```

#### 93、各种协议

```
ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 
TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 
HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 
DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
```

#### 94、 attribute和property的区别是什么？ 

```
attribute是dom元素在文档中作为html标签拥有的属性；
property就是dom元素在js中作为对象拥有的属性。
所以：
对于html的标准属性来说，attribute和property是同步的，是会自动更新的。
但是对于自定义的属性来说，他们是不同步的。
```

#### 95、 说说严格模式的限制 

```
1、变量必须声明后再使用
2、函数的参数不能有同名属性，否则报错
3、不能使用with语句
4、不能对只读属性赋值，否则报错
5、不能使用前缀0表示八进制数，否则报错
6、不能删除不可删除的属性，否则报错
7、不能删除变量delete prop，会报错，只能删除属性delete global[prop]
8、eval不会在它的外层作用域引入变量
9、eval和arguments不能被重新赋值
10、arguments不会自动反映函数参数的变化
11、不能使用arguments.callee
12、不能使用arguments.caller
13、禁止this指向全局对象
14、不能使用fn.caller和fn.arguments获取函数调用的堆栈
15、增加了保留字（比如protected、static和interface）

设立”严格模式”的目的，主要有以下几个：
	（a）消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
	（b）消除代码运行的一些不安全之处，保证代码运行的安全；
	（c）提高编译器效率，增加运行速度；
	（d）为未来新版本的Javascript做好铺垫。

注：经过测试IE6,7,8,9均不支持严格模式。
```

#### 96、 javascript继承的几种方法 

```
1，原型链继承
2，借用构造函数继承
3，组合继承(原型+借用构造)
4，原型式继承
5，寄生式继承
6，寄生组合式继承
```

#### 97、javascript对象的几种创建方式

```
0，字面量方式
1，工厂函数方式
2，构造函数模式 
3，原型模式 
4，混合构造函数和原型模式
5，动态原型模式 
6，寄生构造函数模式 
7，稳妥构造函数模式
```

#### 98、 js继承方式及其优缺点 

```
继承：具有上下关系的两个构造函数，下级构造函数可以访问上级构造函数的属性和方法

原型链继承的缺点：
	一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。

借用构造函数（类式继承）：
	借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承。

组合式继承：

组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。
```

#### 99、 框架和库的区别 

```
框架:是一套完整的解决方案;对项目的侵入性较大,项目如果需要更换框架,则需要重新构整个项目。

库(插件):提供某一个小功能,对项目的侵入性较小,如果某个库无法完成某些需求,可以很容易切换到其它库实现需求.
```

#### 100、forEach和map的区别

```
一、相同点：
1.都是循环遍历数组中的每一项

2.每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）

3.匿名函数中的this都是指向window

4.只能遍历数组

二、不同点
1.map()会分配内存空间存储新数组并返回，forEach()不会返回数据。

2.forEach()允许callback更改原始数组的元素。map()返回新的数组。
```

#### 101、jsonp原理

```
https://www.cnblogs.com/boystar/p/7466049.html
https://www.cnblogs.com/xiaoxie2016/p/6293781.html
```

#### 102、网页验证码是干嘛的

```
区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码，刷票，论坛灌水

有效防止黑客对某一个特定注册用户，用特定程序暴力破解方式，进行不断地登陆尝试


您好，网页的图片验证码是用于人机识别的，用于区分人的操作行为和机器行为。比如，春节购票系统为了防止被恶意机器盗刷，恶意占票，退出的图片验证码，由于机器无法准确识别图片中的内容，从而保障了正常的购票行为。网页的登录验证码，属于双因素认证应用到账号安全的范畴，作用是确保是用户本人进行登录，大大降低了由于账号被盗，导致的非授权登录行为。网页的注册验证码，是验证注册者的身份，防止恶意注册，确保用户的有效性。
```

#### 103、[页面可见性（Page Visibility API） 可以有哪些用途？]

```
页面可见性： 就是对于用户来说，页面是显示还是隐藏, 所谓显示的页面，就是我们正在看的页面；隐藏的页面，就是我们没有看的页面。 因为，我们一次可以打开好多标签页面来回切换着，始终只有一个页面在我们眼前，其他页面就是隐藏的，还有一种就是.........，(把浏览器最小化，所有的页面就都不可见了)。

API 很简单，document.hidden 就返回一个布尔值，如果是true, 表示页面可见，false 则表示，页面隐藏。  不同页面之间来回切换，触发visibilitychange事件。 还有一个document.visibilityState, 表示页面所处的状态，取值：visible, hidden 等四个。
```

#### 104、ES5 和 ES6 之间的区别

```
什么是ES5
作为ECMAScript第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下。

1. strict模式
严格模式，限制一些用法，'use strict';

2. Array增加方法
增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法

PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now

3. Object方法
Object.getPrototypeOf
Object.create
Object.getOwnPropertyNames
Object.defineProperty
Object.getOwnPropertyDescriptor
Object.defineProperties
Object.keys
Object.preventExtensions / Object.isExtensible
Object.seal / Object.isSealed
Object.freeze / Object.isFrozen
什么是ES6

ECMAScript6在保证向下兼容的前提下，提供大量新特性

1.块级作用域 关键字let, 常量const

2.对象字面量的属性赋值简写
```

#### 105、如何判断一个数的整数

```
https://www.jianshu.com/p/94dfa987e379
https://blog.csdn.net/u012155729/article/details/78135393

js 代码执行过程分为两个阶段
词法分析：词法分析主要包括：分析变量声明、分析函数声明、分析形参三个部分。
执行阶段


.关于回调函数和js单线程以及js异步机制

我们都知道js是单线程的，这种设计模式给我们带来了很多的方便之处，我们不需要考虑各个线程之间的通信，也不需要写很多烧脑的代码，也就是说js的引擎只能一件一件事的去完成和执行相关的操作，所以所有需要执行的事情都像排队一样，等待着被触发和执行，可是如果这样的话，如果在队列中有一件事情需要花费很多的时间，那么后面的任务都将处于一种等待状态，有时甚至会出现浏览器假死现象，例如其中有一件正在执行的一个任务是一个死循环，那么会导致后续其他的任务无法正常执行，所以js在同步机制的缺陷下设计出了异步模式
```

#### 106、ES6的新增方法

```
https://juejin.im/post/5cef46226fb9a07eaf2b7516
```

#### 107、使用class 手写一个promise

```
//创建一个Promise的类
  class Promise{
    constructor(executer){//构造函数constructor里面是个执行器
      this.status = 'pending';//默认的状态 pending
      this.value = undefined//成功的值默认undefined
      this.reason = undefined//失败的值默认undefined
      //状态只有在pending时候才能改变
      let resolveFn = value =>{
        //判断只有等待时才能resolve成功
        if(this.status == pending){
          this.status = 'resolve';
          this.value = value;
        }
      }
      //判断只有等待时才能reject失败
      let rejectFn = reason =>{
        if(this.status == pending){
          this.status = 'reject';
          this.reason = reason;
        }
      }    
      try{
        //把resolve和reject两个函数传给执行器executer
        executer(resolve,reject);
      }catch(e){
        reject(e);//失败的话进catch
      }
    }
    then(onFufilled,onReject){
      //如果状态成功调用onFufilled
      if(this.status = 'resolve'){
        onFufilled(this.value);
      }
      //如果状态失败调用onReject
      if(this.status = 'reject'){
        onReject(this.reason);
      }
    }
  }
```

#### 108、Ajax 解决浏览器缓存问题

<https://www.jianshu.com/p/4f76f06383ec>

```
如何创建一个ajax
(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象
(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
(3)设置响应HTTP请求状态变化的函数
(4)发送HTTP请求
(5)获取异步调用返回的数据
(6)使用JavaScript和DOM实现局部刷新
```

```
同步和异步的区别
同步：
浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作

异步：
浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容
```

```
ajax的优点和缺点
ajax的优点

1、无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）
2、异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）
3、前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）
4、界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）

ajax的缺点

1、ajax不支持浏览器back按钮
2、安全问题 Aajax暴露了与服务器交互的细节
3、对搜索引擎的支持比较弱
4、破坏了Back与History后退按钮的正常行为等浏览器机制
```

#### 109、上传图片

<https://www.cnblogs.com/gongyue/p/7686359.html>

#### 110、HTTP和https

<https://www.cnblogs.com/shoshana-kong/p/10520770.html>

#### 111、HTTP/HTTPS

```
网络分层
目前网络分层可分为两种：OSI 模型和 TCP/IP 模型

OSI模型
应用层（Application）
表示层（Presentation）
会话层（Session）
传输层（Transport）
网络层（Network）
数据链路层（Data Link）
物理层（Physical）

TCP/IP模型
应用层（Application）
传输层（Host-to-Host Transport）
互联网层（Internet）
网络接口层（Network Interface）

HTTP/HTTPS
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

HTTP状态码
区分状态码
1××开头 - 信息提示
2××开头 - 请求成功
3××开头 - 请求被重定向
4××开头 - 请求错误
5××开头 - 服务器错误

常见状态码
200 - 请求成功，Ajax 接受到信息了
400 - 服务器不理解请求
403 - 服务器拒绝请求
404 - 请求页面错误
500 - 服务器内部错误，无法完成请求
```

#### 112、原型

> ①所有`引用类型`都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象
> ②所有`函数`都有一个`prototype(原型)`属性，属性值是一个普通的对象
> ③所有`引用类型的__proto__`属性`指向`它`构造函数的prototype`

#### 113、ES5与ES6的区别 ES6与ES7的区别 

```

```

#### 114、SDK

```

```

#### 115、前端开发的规范

```
1、代码的输写规范

```

#### 116、webpack打包速度优化

```

```

#### 117、项目是如何打包的

#### 118、打乱数组

```
https://blog.csdn.net/m0_38082783/article/details/79579116
```



[https://www.cnblogs.com/onepixel/p/5126046.html]: 
[https://www.jianshu.com/p/21dfb470809c]: 
